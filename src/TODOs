Examples
  Parsing all kinds of types
  Mandelbrot explorer
  Game of life
  
Other needs
  Multiplying together vectors, matrices, and tensors
  Fix and flesh out tensor classes
  Matrices: norm (more than one kind), det, invert
  Add more types:
    float32 and complex32 and quat32 and oct32
    bit: 2, 4, 12, 20, 24, 128
    int types above as both signed and unsigned
  Add tests
  polynomials
  gaussian integers
    are they integers? do they not divide?
  group ring, modules (and l and r versions)
  functions of a real variable as a vector space
  vector direct product creating tensors
  improve exp() and log() accuracy near 1.0 / - 1.0
  improve cbrt() accuracies
  big decimal type needed?
  number bases: instead of zero and unity need faster ways to construct
    numbers besides strings
  find all TODOs in code and implement
  power<u> might not be in right place in hierarchy
  make sure all math ops can safely work if (a,b,c) params collide. use
   extra tmps and assign().
  check: IEEE 754 might specify that a num with one component inf and
    any nan might be considered inf. apache commons math4 copies my
    implementation. This affects complex, quat, and oct. Now I assume a
    nan overrides all.
  complex numbers: polar constructors
  quotient/remainder as well as div/mod
    later note: are they different? for instance do they treat neg nums
    differently? I am hoping that I can calc one from the other.
  there are numerous kinds of norms. can embed a default impl for some
    types. but should implement families of reusable norm implementations
  group hierarchy could be multithreaded
  must finish tensor classes
  must finish octonion classes
  must finish rmodule classes
  numerical algorithms put in place: matrix algebra, odes, pdes,
    interpolation, etc.
  underflow avoidance on sqrt calls
  bessel functions, legendre functions, airy functions, others
  some of the type classes rely on ArrayStorage. break this dependence
    to support huge math operations
  make vectors, rmodules, matrices use multidimaccessor
  apache commons math4 does a lot of things my code does
    it doesn't have all of algebra hierarchy and it doesn't have octs or
    all the data types I support and it doesn't handle huge datasets and
    it might be slow due to lots of memory allocation
Sparse vector/matrix/tensor storage
String constructors for numeric types: how about character stream
  constructors instead
Remove much duplication in FileStorage classes when they are done
Support sparse allocation methods
String constructors of numeric types default to DENSE ARRAY. Maybe allow
  mem storage params.
The constructors/duplicators for storage may duplicate other storage
  classes. Due to time lags this is not necessarily threadsafe. Obtain
  locks. Done for file storage classes. (Do the storage classes implement
  Duplicatable interface?)
use vector/rmodule init() inside their own operations: c.init(targetSize).
  this is cuz vectors no longer autosize.
Investigate other libraries: Colt (java), Gnu sci lib, Imglib, boost,
  other fortran classics, apache commons, jscience
  Boost headers for complex and quats can give valuable design ideas.
    Need a ref for octs.
    http://www.boost.org/doc/libs/1_65_1/boost/math/octonion.hpp
0^0 should be nan or throw an exception. right now it returns 1 for
  matrices and tensors. Fix.
rmodules have right and left subtypes: see that AWchap3.pdf file I
  downloaded
make arraybit support multibit value encodings
Add some unsigned types and some bit types like 4 and 12. And 128 bit
  signed ints and maybe a floating point implementation or a BigDecimal
  backed implementation.
Notice that any type can also implement the ByteCoder interface. But not
  variable sized?
FileStorage classes: eliminate duplication
  Add a saveTo(filename) method that will allow one to flush buffer and
    encode data to a file.
  Maybe also a constructor from a filename. The ctor would have to calc
    how big the file is in type.elements() and then read the file and
    append a BUFFER page to the end.
Write Imglib2 test code to do the DFT example and time compare them.
  Did so. My code is a little more elegant, is more complete (has
  complex exp() defined), and a teensy bit faster (1-3 millisecs).
Do i need to look at nio? Do I need to think about streams rather than
  arrays and RAFs?
ArrayBit Storage: flesh out
Some types could be bit encodable but also byte encodable with extra
  bits set to zero to byte boundaries. For instance a 12-bit number
  could be encoded as two bytes
Do I make all types have constructors from all or some primitive types
  so I can make generic code that can use primitives? Otherwise the code
  is ugly.
How do you store matrices? byte encoder and store row and col count
  first? This is a serialization issue. Should think of how java
  approaches this.
Also character stream encoding. Can use my numeric string format.
Support unsigned int types for all defined int types
It's becoming more apparent that all types should implement ByteCoder.
RGB could be a BitCoder of three 8 bit values
  This might be a good test of BitCoder. BitCount = 24. Read or write 1
  or 2 longs in BitCoder impl. How is RGB a numeric type? What algebra
  does it support? Maybe as a test make a 4 bit unsigned type and a 132
  bit unsigned type.
FileStorage bit is possible but slow. It could do file reads and rewind
  and then file writes.
LUDecomposition for multiple types: (float, comp, quat, oct)
  This would require a bool within(U,U) method. Also maybe not possible
  because it requires an Ordered relation? Maybe I'm wrong here.
Types should specify a preferred order of encoding choices so storage
  allocation is optimal. Then types can implement a ton of coder
  interfaces.
Test that the speed of sinAndCos and sinhAndCosh is worthwhile for actual data.
  Also test their accuracy (i.e. sinAndcos might round a little). Can
  sinhAndCosh do a 1.0 - x relation like sinAndCos?
Resurrect Function ideas? Useful for TextSpecified PointSets and Functions
add bounds for samplings? translate and maybe scale and maybe rotate them?
  Ideally there would be a sampling that transforms a real sampling to a
  different space. Thus you could specify simple cylindrical coords and
  then transform it to locate a cylindrical grid in any orientation in
  3d space. Then can throw (x,y,z) coords at it and the contains() method
  for the transformable grid code would transform into space local to
  embedded 3d cylindrical grid and uses those local coords to query the
  contains() method of the cylindrical grid. This is cool but requires
  some thought in how to clearly specify an embedding of grid in 3d space.
  One thought: you embed a grid in 3d space by taking a point and three
  orthonormal direction vectors giving positive x,y,z axes. Orthonormal
  might be unnecessary. Projective might be good enough.
Have a Region interface which is like Sampling interface but it does not
  have iterator. Make RegionUnion etc. parallel to samplings. It may contain
  LongIndex and RealIndex checking simultaneously. contains() is simplified
  greatly.
Regions likely need bounds. Samplings might not. If I make AND OR etc.
  operations with Regions do I need to calculate intersection boundaries?
  Or can I fake it and just use contains()?
Test all the contains() methods in real grid sampling code. Make tolerance
  an internal constant or a passable parameter. Or calc a tol from dx, dy, dz
  and counts.
Revisit all todos noted in sampling code
Make some types implement Dimensioned
How do you using Samplings with Regions. Should be able to sample a region easily.
Right now file storage classes lock their whole buffer. we should block single
  indices at a time so that multiple threads can access the container at one time
  and not cause page faults or slow synchronization.
I don't think I need bounds of samplings. One can iterate a sampling and calc
  bounds. I might need bounds for regions. One could take a region, get its
  bounds, generate a grid sampling on the bounds, and sample the region.
Can I make real grid samplings more generic and use byte[], or short[], or float[]
  as well? Not just long[] and double[].
Text specified region or sampling. The text can be multiple equations with &&
  clauses. A grid spacing included. Note the && could just be supported with two
  text specified regions or samplings and calced via a sampling intersection. So
  maybe not a great idea.
The goal is to get back to text specified functions and samplings/regions.
  Need to write an equation language and a parser again.
What improvements can I make to Function idea? One input? Multiple? None?
  How do I make the groups that are real/complex/quat/oct function spaces?
Weird idea: make a group with methods that are (static?) Functions that
  implement the group methods. So dbl.multiply().compute(a,b,c); The definition
  of groups reuses the Function idea. And one can pass around functions as
  first class objects if needed. This implies Function1<a>, Function2<a,b>,
  Function3<a,b,c>, and can support any num and type of params. A procedural
  approach to java with all pass by reference and efficient. But also functional.
  And supporting more than the typical primitive types.
Do I need to locate regions and samplings in algebra hierarchy and define
  their group?
Tricky definition: the function that takes an average. It has to take
  as input a set of functions that match in param count and type. And
  then applied for a snapshot of params to the full set and added and
  divided. How do you define the strong type if the declaration where the
  input params vary. In a functional language you can partially apply
  the inputs and really every function takes 1 param or really 0 params
  and a context of other function values. ImageJ takes an Object ... approach
  which requires casting at some level to populate params of plugins.
I have purposely not made things like Matrix<Float64Member> and
  Matrix<Float32Member> to facilitate simple optimization. This results in
  some code duplication.
Constructors are functions like function1, function2, etc. that take
  various parameters and return a type. A group can define the ctors
  it provides.
Conditions can be like functions and ctors: condition1, condition2, etc.
How does previous line affect my current definitions of and or not classes?
Do we get rid of rigid algebraic type hierarchy and define skewfield for
  instance to have multiply function and x function and y function etc.
  Then Octonions aren't quite a skewfield. But they support most of it's
  operations and can be passed to methods that use a subset of skewfield
  operations. In other words ducktyping.
I can write this library in C++ for efficiency.
Make Storage class allocate method look at how big the request is and
  how big the type is and how much ram is available and allocate an
  ArrayStorage or a FileStorage as needed.
When done writing 128 bit unsigned integers test speed versus imglib
Instead of condition2<a,b>, condition3<a,b,c>, etc. do condition<tuple2<a,b>>.
  This is just a maybe idea. Haskell has tuple2, tuple3, etc. up to like
  17. It's okay if I do that too. Just not sure I want to.
  problem with condition1, condition2: the need for multiple and or not xor classes
Notice that Condition<T> and SetMembership<T> are essentially the same concept.
Support more coord system grids: look up types in engineering and math books
Use apache commons to write my DFT example. Test speed and memory use between
  the two libraries
add more operations: skew, kurtosis, other moments, etc. Also I hear that
  my calculation for variance is not a well behaved algorithm.
FileStorage: have multiple buffers and configurable or calculated buffer sizes
  based upon numElements and percents etc.
Constructible interfaces could instead derive from Function interfaces
Must write a lot of tests for the numeric types
Write more Functions, Procedures, Accessors, and Tuples. Beyond 10 params.
  Note that combining tuples and funcs/procs we support 100 params right now.
Somehow replace ctor interfaces with Functions? Not sure I want to. But ctors
  are unwieldy right now. 
With Proc and Func interfaces in place I think it makes sense to define a macro
  language that can be parsed and interpreted as a Proc or Func. I could use a
  subset of that language to define parsable Functions (i.e. text specified).
  It should support reals. complexes, quats, and octs. Each of these have different
  capabilities and can be passed to different functions so must take care.
  Also support vectors, matrices, and tensors. With my string language I can.
String language may need to change a little: replace [] with {} so that macro
  language does not collide with other math concepts that could use [].
  Later edit: I think I really mean replace () with {}. Parentheses are valuable
  to equation grammars in many ways.
Need out of bounds conventions (and methods) for multidim and linear access.
Do I make Tuple and Proc and Func more generic? Like Tuple could be one type
  with N elements and querying less 0 <= x < N returns the element and >= N
  throws an exception. Not strongly typed but each param has a .class associated
  with it so can safely cast. This approach could be used for Proc and Func as
  well. Cleaner but how performant is it? In the case of a Condition it might
  have to check the shape of the tuple on every invocation. Or it just queries
  the n things it cares about. But must cast every arg. For func and proc the
  macro language idea would prefer the Object approach with runtime checks.
  But right now the tuples are compile time typed.
Default values for functions/procedures can be defined in the code of such
  things. So if null comes in the code defines the value. It's not a feature
  as much as its a practice.
AddProc is one level higher than Add which uses primitives only. AddProc uses
  procedures and threadlocal variables. Do we want to change all simple procedures
  like sin, cos, etc. to use this approach? A parser certainly would need that.
How to combine strong generic typing with parsed code which has procedures of
  varying parameter types? Also have Add(3 octs), Add(3 floats), etc. Also want
  to Add(Oct, Real, Oct) etc. Really? Which component are we adding the Real to?
  By default the 1st/real component. But how can you add 5 to the imag component?
  Maybe we index numbers. Real[1], Complex[2], Quat[4], Oct[8]. And have
  Add(Num, Index, Value, ResultNum). Its an error to assign ResultNum[i] if value
  is nonzero and i > num components available in ResultNum.
Constant class: should be a proc for n = 0 to +inf params. A ton of Constant classes?
  Whats a good solution? In qdiffle I said it could handle any dimensionality. This
  approach makes some sense.
Define a Signed and an Unsigned marker interface. Attach to various types.
  Can test for in <T> signatures if one or the other is needed for an algorithm.
  Similarly for Exact vs. Approximate. We already have Bounded and Infinite.
Do I remove all stack oriented numeric objects in the types and use static threadlocals
  instead? This might look confusing but might be faster. If stack objects get
  optimized to stack struct variables it would not.
Support both kinds (logical and arithmetic) of right shift operator for int classes
Make sure all types can be exported to and imported from the primitive types and
  BigInteger and BigDecimal.
Are the random(U) implementations threadsafe? That depends upon java lib. Investigate.
  Need to use ThreadLocalRandom. Do so.
128 bit unsigned needs both kinds of shift right and not just one
64 bit unsigned needs some tests
Can I break 128-bit multiply into pieces that I can multiply together a chunk
  at a time and avoid all the shift/add calls? Similar question for divide.
Are the mod() implementations for signed ints right when a == minint and b == -1
Test float16 by iterating thru 65536 combos and going toFloat().toShort() and
  making sure there is no drift in the process. NaNs will drift as implemented
  so catch that.
change Conditions to Sets
add Sinc/pi and Sinch/pi interfaces and computations to the hierarchy
erf/erfc needs to be implemented
implement pulling random values out of statistical distributions as
  algorithms if possible
add javadoc to each of the algorithms
rename IntegralDivision to ModularDivision?
In java floats support the % operator. Could support part of IntegralDivision
  and this would allow Integral algorithms to work with them. But gcd/lcm
  and isOdd/isEven make no sense for floats. Break apart IntegralDivision
  into at least two pieces.
Can pred/succ fail on floats because of boundary conditions? Some algos
  might test against zero while floats might start negative and stick at
  negative infinity. Must review pred/succ assumptions. Might be okay if
  number is not NaN or infinity and our algorithm goes to/from zero or
  minbound/maxbound.
Conversions: (complex/quat/oct) and (vector/matrix/tensor)
Define linear storage filters that allow one to treat disconnected indices
  as a linear storage. This allows sums/avgs/etc to be computed on subsets
  of linear storage. Can Samplings factor in here?
Should I implement Rational classes? And a BigDecimal based class?
LinearStorage should implement the Duplicatable interface. Maybe also a
  Sortable interface. Median would require a Sortable DataSource. Does a
  DataSource have a size()? What about streams?
The array storage classes should duplicate the input type maybe. maybe not.
Make signed 128-bit code, add non-exhaustive tests, and enable group in G
Add more constants to the Constants interface
Find all places that might try to find hiBit and use Integer.numLeadZero()
Make Power and PowerI applicable to matrices and maybe tensors. Think.